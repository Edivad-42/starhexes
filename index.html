<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1e293b">
    <meta name="description" content="Star Hexes - Gioco tattico a turni nello spazio">
    <title>Star Hexes</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <script src="abilities.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            width: 100vw;
            height: 100vh;
        }
        * {
            -webkit-tap-highlight-color: transparent;
        }
        #root {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        const StarHexesGame = () => {
          // Game state: 'menu' or 'game'
          const [gameState, setGameState] = useState('menu');
          
          // State management
          const [config, setConfig] = useState(null);
          const [units, setUnits] = useState([]);
          const [capitalShips, setCapitalShips] = useState({ player1: null, player2: null });
          const [currentPlayer, setCurrentPlayer] = useState(1);
          const [selectedUnit, setSelectedUnit] = useState(null);
          const [activatedUnits, setActivatedUnits] = useState(new Set());
          const [gamePhase, setGamePhase] = useState('action'); // 'action' or 'combat'
          const [combatLog, setCombatLog] = useState([]);
          const [visibleCombatEvents, setVisibleCombatEvents] = useState([]);
          const [needsAIMove, setNeedsAIMove] = useState(false);
          const [activeAbility, setActiveAbility] = useState(null); // Currently active ability
          const [abilityTargets, setAbilityTargets] = useState([]); // Valid targets for active ability
          const [showUnitInfo, setShowUnitInfo] = useState(false); // Unit info modal visibility
          
          // Refs to access latest state in async operations
          const unitsRef = useRef(units);
          const activatedRef = useRef(activatedUnits);
          
          // Keep refs synchronized with state
          useEffect(() => {
            unitsRef.current = units;
            activatedRef.current = activatedUnits;
          }, [units, activatedUnits]);

          // Load game configuration and initialize units
          useEffect(() => {
            fetch('config.json')
              .then(res => res.json())
              .then(data => {
                setConfig(data);
                
                // Initialize capital ships with current health
                setCapitalShips({
                  player1: {
                    ...data.capitalShips.player1,
                    currentHealth: data.capitalShips.player1.health
                  },
                  player2: {
                    ...data.capitalShips.player2,
                    currentHealth: data.capitalShips.player2.health
                  }
                });
                
                // Create initial units for both players
                const initialUnits = [];
                let unitId = 1;
                
                data.startingUnits.player1.forEach(u => {
                  const unitType = data.unitTypes[u.type];
                  const newUnit = {
                    id: `p1_${unitId++}`,
                    player: 1,
                    q: u.q,
                    r: u.r,
                    health: unitType.health,
                    maxHealth: unitType.health,
                    type: u.type,
                    damage: unitType.damage,
                    capitalDamage: unitType.capitalDamage
                  };
                  // Initialize abilities system for this unit
                  if (unitType.abilities) {
                    AbilitySystem.initAbilities(newUnit, unitType.abilities);
                  }
                  initialUnits.push(newUnit);
                });
                
                unitId = 1;
                data.startingUnits.player2.forEach(u => {
                  const unitType = data.unitTypes[u.type];
                  const newUnit = {
                    id: `p2_${unitId++}`,
                    player: 2,
                    q: u.q,
                    r: u.r,
                    health: unitType.health,
                    maxHealth: unitType.health,
                    type: u.type,
                    damage: unitType.damage,
                    capitalDamage: unitType.capitalDamage
                  };
                  // Initialize abilities system for this unit
                  if (unitType.abilities) {
                    AbilitySystem.initAbilities(newUnit, unitType.abilities);
                  }
                  initialUnits.push(newUnit);
                });
                
                setUnits(initialUnits);
              })
              .catch(err => {
                console.error('Errore caricamento config:', err);
              });
          }, []);

          // Check if all units are activated to trigger combat phase
          useEffect(() => {
            if (gamePhase !== 'action') return;
            
            const aliveUnits = units.filter(u => u.health > 0);
            if (aliveUnits.length === 0) return;
            
            const allActivated = aliveUnits.every(u => activatedUnits.has(u.id));
            
            if (allActivated) {
              resolveCombat();
            }
          }, [activatedUnits, gamePhase]);

          // Trigger AI move when needed
          useEffect(() => {
            if (!needsAIMove || gamePhase !== 'action' || currentPlayer !== 2) return;
            
            const timer = setTimeout(() => {
              makeAIMove();
            }, config?.ui?.animationSpeed || 1000);
            
            return () => clearTimeout(timer);
          }, [needsAIMove, gamePhase, currentPlayer]);

          if (!config) {
            return (
              <div className="w-full h-full bg-gray-800 flex items-center justify-center">
                <div className="text-white text-xl">Loading...</div>
              </div>
            );
          }

          // Hexagonal grid utilities
          const hexUtils = {
            // Get all 6 neighboring hexes for offset coordinates
            getNeighbors: (q, r) => {
              const evenRow = r % 2 === 0;
              if (evenRow) {
                return [
                  [q + 1, r], [q - 1, r],      // right, left
                  [q, r - 1], [q - 1, r - 1],  // top-right, top-left
                  [q, r + 1], [q - 1, r + 1]   // bottom-right, bottom-left
                ];
              } else {
                return [
                  [q + 1, r], [q - 1, r],      // right, left
                  [q + 1, r - 1], [q, r - 1],  // top-right, top-left
                  [q + 1, r + 1], [q, r + 1]   // bottom-right, bottom-left
                ];
              }
            }
          };

          const PlaneIcon = ({ x, y, size, color }) => (
            <path
              d={`M ${x} ${y-size/2} L ${x+size/3} ${y+size/2} L ${x} ${y+size/3} L ${x-size/3} ${y+size/2} Z`}
              fill={color}
              style={{ pointerEvents: 'none' }}
            />
          );

          const isOccupied = (q, r, excludeId = null) => {
            return unitsRef.current.some(u => u.q === q && u.r === r && u.id !== excludeId && u.health > 0);
          };

          const getUnitAt = (q, r) => {
            return unitsRef.current.find(u => u.q === q && u.r === r && u.health > 0);
          };

          const isEngaged = (unit) => {
            const neighbors = hexUtils.getNeighbors(unit.q, unit.r);
            const enemyNeighbors = neighbors.filter(([q, r]) => {
              const neighbor = getUnitAt(q, r);
              return neighbor && neighbor.player !== unit.player;
            });
            return enemyNeighbors.length > 0;
          };

          const canMove = (unit) => {
            if (!isEngaged(unit)) return true;
            
            const neighbors = hexUtils.getNeighbors(unit.q, unit.r);
            const enemyNeighbors = neighbors.filter(([q, r]) => {
              const neighbor = getUnitAt(q, r);
              return neighbor && neighbor.player !== unit.player;
            });
            
            if (enemyNeighbors.length === 1) return false;
            
            return enemyNeighbors.every(([q, r]) => {
              const enemy = getUnitAt(q, r);
              const enemyEngagements = hexUtils.getNeighbors(q, r).filter(([nq, nr]) => {
                const n = getUnitAt(nq, nr);
                return n && n.player !== enemy.player;
              });
              return enemyEngagements.length > 1;
            });
          };

          const getValidMoves = (unit) => {
            if (!canMove(unit)) return [];
            
            // Se c'√® un'abilit√† di movimento attiva, usa quella
            if (activeAbility && ABILITIES[activeAbility]?.trigger === 'movement') {
              const ability = ABILITIES[activeAbility];
              const result = ability.effect(unit, { config, isOccupied }, hexUtils);
              return result.validMoves || [];
            }
            
            // Movimento normale
            const neighbors = hexUtils.getNeighbors(unit.q, unit.r);
            return neighbors.filter(([q, r]) => 
              q >= 0 && q < config.map.width && 
              r >= 0 && r < config.map.height && 
              !isOccupied(q, r, unit.id)
            );
          };

          const handleUnitClick = (unit) => {
            if (gamePhase !== 'action') return;
            
            // Always allow selecting any unit for info viewing
            setSelectedUnit(unit);
            setActiveAbility(null);
            setAbilityTargets([]);
            setShowUnitInfo(false);
            
            // If it's not your turn, not your unit, or already activated, 
            // the unit is selected but can only be viewed (no actions available)
            if (unit.player !== currentPlayer || currentPlayer !== 1 || activatedUnits.has(unit.id)) {
              return;
            }
          };

          const handleAbilityClick = (abilityId) => {
            if (!selectedUnit) return;
            
            const ability = ABILITIES[abilityId];
            if (!ability) return;
            
            // Check if unit can use this ability
            if (ability.type === 'active' && !ability.canUse(selectedUnit, {})) return;
            
            if (ability.trigger === 'movement') {
              // Movement ability: activate and show extended movement range
              setActiveAbility(abilityId);
              setAbilityTargets([]);
            } else if (ability.trigger === 'attack') {
              // Attack ability: show valid targets
              const result = ability.effect(selectedUnit, { config, getUnitAt }, hexUtils);
              setActiveAbility(abilityId);
              setAbilityTargets(result.targetHexes || []);
            } else if (ability.trigger === 'combat') {
              // Combat buff ability: activate immediately for this turn
              ability.onUse(selectedUnit);
              setUnits(prevUnits => prevUnits.map(u => 
                u.id === selectedUnit.id ? { ...selectedUnit } : u
              ));
              setActiveAbility(null);
            }
          };

          const makeAIMove = () => {
            setNeedsAIMove(false);
            
            // Find AI units that haven't been activated yet
            const aiUnits = unitsRef.current.filter(u => u.player === 2 && u.health > 0 && !activatedRef.current.has(u.id));
            
            if (aiUnits.length === 0) {
              setCurrentPlayer(1);
              return;
            }

            const aiUnit = aiUnits[0];
            const playerUnits = unitsRef.current.filter(u => u.player === 1 && u.health > 0);
            const validMoves = getValidMoves(aiUnit);

            // If unit can't move, just activate it
            if (!canMove(aiUnit) || validMoves.length === 0) {
              setActivatedUnits(prev => new Set([...prev, aiUnit.id]));
              setCurrentPlayer(1);
              return;
            }

            // Simple AI: find move that gets closest to any enemy unit
            let bestMove = validMoves[0];
            let minDistance = Infinity;

            validMoves.forEach(([mq, mr]) => {
              playerUnits.forEach(pUnit => {
                const dist = Math.abs(mq - pUnit.q) + Math.abs(mr - pUnit.r);
                if (dist < minDistance) {
                  minDistance = dist;
                  bestMove = [mq, mr];
                }
              });
            });

            // Execute move
            setUnits(prevUnits => prevUnits.map(u => 
              u.id === aiUnit.id ? { ...u, q: bestMove[0], r: bestMove[1] } : u
            ));
            setActivatedUnits(prev => new Set([...prev, aiUnit.id]));
            setCurrentPlayer(1);
          };

          const handleHexClick = (q, r) => {
            if (!selectedUnit || gamePhase !== 'action' || currentPlayer !== 1) return;
            
            // Can't move if not player 1's unit or already activated
            if (selectedUnit.player !== 1 || activatedUnits.has(selectedUnit.id)) return;
            
            // If there's an attack ability active, handle target
            if (activeAbility && ABILITIES[activeAbility]?.trigger === 'attack') {
              const isValidTarget = abilityTargets.some(([tq, tr]) => tq === q && tr === r);
              if (isValidTarget) {
                const ability = ABILITIES[activeAbility];
                const attackData = ability.onUse(selectedUnit, [q, r]);
                
                // Applica danno immediato al target
                setUnits(prevUnits => prevUnits.map(u => {
                  if (u.q === q && u.r === r && u.player !== selectedUnit.player) {
                    return { ...u, health: Math.max(0, u.health - attackData.damage) };
                  }
                  if (u.id === selectedUnit.id) {
                    return { ...selectedUnit };
                  }
                  return u;
                }));
                
                // Reset abilit√† ma NON attivare l'unit√† - pu√≤ ancora muovere
                setActiveAbility(null);
                setAbilityTargets([]);
                return;
              }
            }
            
            // Movimento normale o con abilit√†
            const validMoves = getValidMoves(selectedUnit);
            const isValidMove = validMoves.some(([mq, mr]) => mq === q && mr === r);
            
            if (isValidMove) {
              // Se c'√® un'abilit√† di movimento attiva, consumala
              if (activeAbility && ABILITIES[activeAbility]?.trigger === 'movement') {
                ABILITIES[activeAbility].onUse(selectedUnit);
              }
              
              setUnits(prevUnits => prevUnits.map(u => 
                u.id === selectedUnit.id ? { ...u, q, r } : u
              ));
              setActivatedUnits(prev => new Set([...prev, selectedUnit.id]));
              setSelectedUnit(null);
              setActiveAbility(null);
              setAbilityTargets([]);
              setCurrentPlayer(2);
              setNeedsAIMove(true);
            }
          };

          const handlePass = () => {
            if (!selectedUnit) return;
            if (activatedUnits.has(selectedUnit.id)) return;

            setActivatedUnits(prev => new Set([...prev, selectedUnit.id]));
            setSelectedUnit(null);
            setActiveAbility(null);
            setAbilityTargets([]);
            setCurrentPlayer(2);
            setNeedsAIMove(true);
          };

          const resolveCombat = () => {
            setGamePhase('combat');
            const log = [];
            const currentUnits = [...unitsRef.current];
            let newCapitalShips = { ...capitalShips };

            const combatPairs = new Map();
            
            currentUnits.forEach(unit => {
              if (unit.health <= 0) return;
              
              const neighbors = hexUtils.getNeighbors(unit.q, unit.r);
              const enemies = neighbors
                .map(([q, r]) => currentUnits.find(u => u.q === q && u.r === r && u.health > 0))
                .filter(n => n && n.player !== unit.player);
              
              if (enemies.length > 0) {
                const damagePerEnemy = unit.damage / enemies.length;
                enemies.forEach(enemy => {
                  const key = [unit.id, enemy.id].sort().join('-');
                  if (!combatPairs.has(key)) {
                    combatPairs.set(key, { unit, enemy, damage: damagePerEnemy });
                  }
                });
              }
            });

            const newUnits = currentUnits.map(u => ({ ...u }));

            combatPairs.forEach(({ unit, enemy, damage }) => {
              const unitIdx = newUnits.findIndex(u => u.id === unit.id);
              const enemyIdx = newUnits.findIndex(u => u.id === enemy.id);
              
              if (unitIdx !== -1 && enemyIdx !== -1) {
                // Applica modificatori passivi di attacco
                let finalDamageToEnemy = AbilitySystem.applyPassiveAttack(unit, damage, config);
                let finalDamageToUnit = AbilitySystem.applyPassiveAttack(enemy, damage, config);
                
                // Applica modificatori passivi di difesa
                finalDamageToEnemy = AbilitySystem.applyPassiveDefense(newUnits[enemyIdx], finalDamageToEnemy, config);
                finalDamageToUnit = AbilitySystem.applyPassiveDefense(newUnits[unitIdx], finalDamageToUnit, config);
                
                newUnits[unitIdx].health = Math.max(0, newUnits[unitIdx].health - finalDamageToUnit);
                newUnits[enemyIdx].health = Math.max(0, newUnits[enemyIdx].health - finalDamageToEnemy);
                log.push(`${unit.id} and ${enemy.id} deal ${finalDamageToEnemy.toFixed(0)}/${finalDamageToUnit.toFixed(0)} damage`);
              }
            });

            // Danni alle navi capitali
            newUnits.forEach(unit => {
              if (unit.health <= 0) return;
              
              const isInP1CapitalZone = config.capitalZones.player1.some(z => z.q === unit.q && z.r === unit.r);
              const isInP2CapitalZone = config.capitalZones.player2.some(z => z.q === unit.q && z.r === unit.r);
              const isInEnemyCapitalZone = unit.player === 1 ? isInP2CapitalZone : isInP1CapitalZone;
              
              if (isInEnemyCapitalZone) {
                const hasEnemyNeighbors = hexUtils.getNeighbors(unit.q, unit.r)
                  .some(([q, r]) => {
                    const n = newUnits.find(u => u.q === q && u.r === r && u.health > 0);
                    return n && n.player !== unit.player;
                  });
                
                if (!hasEnemyNeighbors) {
                  const targetShip = unit.player === 1 ? 'player2' : 'player1';
                  newCapitalShips[targetShip] = {
                    ...newCapitalShips[targetShip],
                    currentHealth: Math.max(0, newCapitalShips[targetShip].currentHealth - unit.capitalDamage)
                  };
                  log.push(`${unit.id} infligge ${unit.capitalDamage} danni alla ${newCapitalShips[targetShip].name}!`);
                }
              }
            });

            setUnits(newUnits);
            setCapitalShips(newCapitalShips);
            setCombatLog(log);
            
            // Reset cooldowns abilit√†
            AbilitySystem.resetCooldowns(newUnits);
            
            setTimeout(() => {
              setGamePhase('action');
              setActivatedUnits(new Set());
              setCombatLog([]);
              setCurrentPlayer(1);
              setSelectedUnit(null);
              setActiveAbility(null);
              setAbilityTargets([]);
            }, config.ui.combatLogDuration);
          };

          const HexGrid = () => {
            const hexSize = config.map.hexSize;
            const hexWidth = hexSize * Math.sqrt(3);
            const hexHeight = hexSize * 2;
            const vertDist = hexHeight * 0.75;
            
            const ship1Pos = config.capitalShips.player1.position;
            const ship2Pos = config.capitalShips.player2.position;
            const disabledHexes = config.map.disabledHexes || [];
            
            const isHexDisabled = (q, r) => {
              return disabledHexes.some(hex => hex.q === q && hex.r === r);
            };
            
            const isInCapitalZone = (q, r, player) => {
              const zones = player === 1 ? config.capitalZones.player1 : config.capitalZones.player2;
              return zones.some(zone => zone.q === q && zone.r === r);
            };
            
            return (
              <svg width="100%" height="100%" className="bg-gray-900" viewBox="0 0 550 380" preserveAspectRatio="xMidYMid meet">
                {Array.from({ length: config.map.height }, (_, r) => 
                  Array.from({ length: config.map.width }, (_, q) => {
                    if (isHexDisabled(q, r)) return null;
                    
                    const x = hexWidth * q + (r % 2) * (hexWidth / 2) + 40;
                    const y = vertDist * r + 35;
                    
                    const unit = units.find(u => u.q === q && u.r === r && u.health > 0);
                    const isSelected = selectedUnit && selectedUnit.q === q && selectedUnit.r === r;
                    const validMoves = selectedUnit ? getValidMoves(selectedUnit) : [];
                    const isValidMove = validMoves.some(([mq, mr]) => mq === q && mr === r);
                    
                    const isP1Capital = isInCapitalZone(q, r, 1);
                    const isP2Capital = isInCapitalZone(q, r, 2);
                    const isShip1 = q === ship1Pos.q && r === ship1Pos.r;
                    const isShip2 = q === ship2Pos.q && r === ship2Pos.r;
                    
                    let fillColor = '#1e293b';
                    let strokeColor = '#475569';
                    let strokeWidth = 2;
                    
                    if (isP1Capital) {
                      strokeColor = '#3b82f6';
                      strokeWidth = 3;
                    }
                    if (isP2Capital) {
                      strokeColor = '#ef4444';
                      strokeWidth = 3;
                    }
                    if (isValidMove) fillColor = '#064e3b';
                    if (isSelected) fillColor = '#fbbf24';
                    
                    return (
                      <g key={`${q}-${r}`}>
                        <polygon
                          points={`${x},${y-hexSize} ${x+hexSize*0.866},${y-hexSize/2} ${x+hexSize*0.866},${y+hexSize/2} ${x},${y+hexSize} ${x-hexSize*0.866},${y+hexSize/2} ${x-hexSize*0.866},${y-hexSize/2}`}
                          fill={fillColor}
                          stroke={strokeColor}
                          strokeWidth={strokeWidth}
                          onClick={() => unit ? handleUnitClick(unit) : handleHexClick(q, r)}
                          className="cursor-pointer hover:opacity-80 transition-opacity"
                        />
                        
                        {/* Navi Capitali */}
                        {isShip1 && capitalShips.player1.currentHealth > 0 && (
                          <>
                            <rect x={x-22} y={y-10} width={44} height={20} rx={4} fill="#1e40af" stroke="#3b82f6" strokeWidth={2} />
                            <text x={x} y={y+4} textAnchor="middle" fill="white" fontSize="10" fontWeight="bold">NAVE</text>
                          </>
                        )}
                        {isShip2 && capitalShips.player2.currentHealth > 0 && (
                          <>
                            <rect x={x-22} y={y-10} width={44} height={20} rx={4} fill="#991b1b" stroke="#ef4444" strokeWidth={2} />
                            <text x={x} y={y+4} textAnchor="middle" fill="white" fontSize="10" fontWeight="bold">NAVE</text>
                          </>
                        )}
                        
                        {/* Unit√† */}
                        {unit && unit.health > 0 && (
                          <>
                            <circle
                              cx={x}
                              cy={y}
                              r={20}
                              fill={config.unitTypes[unit.type].color[`player${unit.player}`]}
                              stroke={activatedUnits.has(unit.id) ? '#22c55e' : '#ffffff'}
                              strokeWidth="3"
                              onClick={() => handleUnitClick(unit)}
                              className="cursor-pointer"
                            />
                            <PlaneIcon x={x} y={y} size={14} color="white" />
                            {config.ui.showHealthNumbers && (
                              <text
                                x={x}
                                y={y + 12}
                                textAnchor="middle"
                                fill="white"
                                fontSize="9"
                                fontWeight="bold"
                                style={{ pointerEvents: 'none' }}
                              >
                                {Math.round(unit.health)}
                              </text>
                            )}
                          </>
                        )}
                      </g>
                    );
                  })
                )}
              </svg>
            );
          };

          return (
            <div className="w-full h-full bg-gray-800 flex flex-col overflow-hidden">
              <div className="flex-1 flex flex-col overflow-hidden">
                <div className="text-center py-1 bg-gray-900 flex-shrink-0">
                  <div className="text-white text-sm">
                    {gamePhase === 'action' ? (
                      <>
                        <span className={currentPlayer === 1 ? 'text-blue-400' : 'text-red-400'}>
                          P{currentPlayer}
                        </span>
                        {' '}- {currentPlayer === 1 ? 'Move unit' : 'AI thinking...'}
                      </>
                    ) : (
                      <span className="text-yellow-400">COMBAT</span>
                    )}
                  </div>
                  
                  {/* Combat Events Feed */}
                  {gamePhase === 'combat' && visibleCombatEvents.length > 0 && (
                    <div className="mt-1 space-y-0.5">
                      {visibleCombatEvents.map((event, index) => (
                        <div 
                          key={event.id}
                          className="text-xs text-gray-300 animate-slide-down"
                          style={{
                            animation: `slideDown 0.3s ease-out`,
                            opacity: 1 - (index * 0.15)
                          }}
                        >
                          {event.type === 'capital' ? 'üéØ' : '‚öîÔ∏è'} {event.text}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
                
                <style>{`
                  @keyframes slideDown {
                    from {
                      transform: translateY(-10px);
                      opacity: 0;
                    }
                    to {
                      transform: translateY(0);
                      opacity: 1;
                    }
                  }
                `}</style>
                
                <div className="flex-1 overflow-hidden relative">
                  <HexGrid />
                  
                  {/* Unit Info Modal */}
                  {selectedUnit && showUnitInfo && (
                    <div 
                      className="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50"
                      onClick={() => setShowUnitInfo(false)}
                    >
                      <div 
                        className="bg-gray-800 rounded-lg p-4 max-w-sm mx-4 border-2"
                        style={{ borderColor: config.players[`player${selectedUnit.player}`].color }}
                        onClick={(e) => e.stopPropagation()}
                      >
                        {/* Header with icon */}
                        <div className="flex items-center gap-3 mb-3">
                          <div 
                            className="w-16 h-16 rounded-lg flex items-center justify-center"
                            style={{ backgroundColor: config.players[`player${selectedUnit.player}`].color }}
                          >
                            <img 
                              src={config.unitTypes[selectedUnit.type].icon} 
                              alt={config.unitTypes[selectedUnit.type].name}
                              className="w-14 h-14"
                            />
                          </div>
                          <div className="flex-1">
                            <h3 className="text-white font-bold text-lg">
                              {config.unitTypes[selectedUnit.type].name}
                            </h3>
                            <p className="text-gray-400 text-xs">
                              {selectedUnit.id} ‚Ä¢ Player {selectedUnit.player}
                            </p>
                          </div>
                        </div>
                        
                        {/* Description */}
                        <p className="text-gray-300 text-sm mb-3 italic">
                          {config.unitTypes[selectedUnit.type].description}
                        </p>
                        
                        {/* Stats */}
                        <div className="grid grid-cols-2 gap-2 mb-3">
                          <div className="bg-gray-700 rounded p-2">
                            <div className="text-gray-400 text-xs">Health</div>
                            <div className="text-white font-bold">
                              {Math.round(selectedUnit.health)} / {selectedUnit.maxHealth}
                            </div>
                            <div className="w-full bg-gray-600 rounded h-1 mt-1">
                              <div 
                                className="bg-green-500 h-1 rounded transition-all"
                                style={{ width: `${(selectedUnit.health / selectedUnit.maxHealth) * 100}%` }}
                              />
                            </div>
                          </div>
                          <div className="bg-gray-700 rounded p-2">
                            <div className="text-gray-400 text-xs">Damage</div>
                            <div className="text-white font-bold">{selectedUnit.damage}</div>
                          </div>
                          <div className="bg-gray-700 rounded p-2 col-span-2">
                            <div className="text-gray-400 text-xs">vs Capital Ships</div>
                            <div className="text-white font-bold">{selectedUnit.capitalDamage}</div>
                          </div>
                        </div>
                        
                        {/* Abilities */}
                        {config.unitTypes[selectedUnit.type].abilities && (
                          <div className="mb-3">
                            <div className="text-gray-400 text-xs font-bold mb-1">ABILITIES</div>
                            <div className="space-y-1">
                              {config.unitTypes[selectedUnit.type].abilities.map(abilityId => {
                                const ability = ABILITIES[abilityId];
                                const state = selectedUnit.abilityStates?.[abilityId];
                                return (
                                  <div key={abilityId} className="bg-gray-700 rounded p-2">
                                    <div className="flex items-center gap-2">
                                      <span className="text-lg">{ability.icon}</span>
                                      <div className="flex-1">
                                        <div className="text-white text-sm font-bold">{ability.name}</div>
                                        <div className="text-gray-400 text-xs">{ability.description}</div>
                                      </div>
                                      {ability.type === 'active' && state && (
                                        <div className="text-xs text-gray-400">
                                          {state.cooldown > 0 ? `CD: ${state.cooldown}` : 
                                           state.charges !== null ? `${state.charges}/${ability.maxCharges}` : '‚àû'}
                                        </div>
                                      )}
                                      {ability.type === 'passive' && (
                                        <div className="text-xs text-green-400">Passive</div>
                                      )}
                                    </div>
                                  </div>
                                );
                              })}
                            </div>
                          </div>
                        )}
                        
                        {/* Close button */}
                        <button
                          onClick={() => setShowUnitInfo(false)}
                          className="w-full py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-600 transition-colors"
                        >
                          Close
                        </button>
                      </div>
                    </div>
                  )}
                  
                  {selectedUnit && gamePhase === 'action' && (
                    <div className="absolute bottom-4 left-1/2 -translate-x-1/2 flex flex-col gap-2">
                      {/* Only show action buttons if it's player 1's turn, their unit, and not activated */}
                      {currentPlayer === 1 && selectedUnit.player === 1 && !activatedUnits.has(selectedUnit.id) && (
                        <>
                          <div className="flex gap-2">
                            <button
                              onClick={handlePass}
                              className="px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-500 active:bg-gray-600"
                            >
                              Pass
                            </button>
                            <button
                              onClick={() => setShowUnitInfo(true)}
                              className="px-4 py-2 bg-blue-700 text-white rounded-lg border border-blue-500 active:bg-blue-600"
                            >
                              ‚ÑπÔ∏è Info
                            </button>
                          </div>
                          
                          {/* Abilities */}
                          {config.unitTypes[selectedUnit.type].abilities && (
                            <div className="flex flex-col gap-1 bg-gray-800 p-2 rounded-lg border border-gray-600">
                              <div className="text-white text-xs font-bold mb-1">Abilities:</div>
                              {AbilitySystem.getAvailableAbilities(selectedUnit, config).map(ability => {
                                const isActive = activeAbility === ability.id;
                                const canUse = ability.type === 'active' && ability.canUse;
                                const charges = ability.state?.charges;
                                const cooldown = ability.state?.cooldown || 0;
                                
                                return (
                                  <button
                                    key={ability.id}
                                    onClick={() => canUse && handleAbilityClick(ability.id)}
                                    disabled={ability.type === 'passive' || !canUse}
                                    className={`
                                      px-3 py-1 rounded text-xs flex items-center gap-2
                                      ${isActive ? 'bg-yellow-600 text-white' : ''}
                                      ${ability.type === 'passive' 
                                        ? 'bg-gray-600 text-gray-400 cursor-not-allowed' 
                                        : canUse 
                                          ? 'bg-blue-600 text-white active:bg-blue-700'
                                          : 'bg-gray-700 text-gray-500 cursor-not-allowed'}
                                    `}
                                  >
                                    <span>{ability.icon}</span>
                                    <span className="flex-1 text-left">{ability.name}</span>
                                    {ability.type === 'active' && (
                                      <span className="text-[10px]">
                                        {cooldown > 0 ? `CD:${cooldown}` : charges !== null ? `${charges}/${ability.maxCharges}` : '‚àû'}
                                      </span>
                                    )}
                                    {ability.type === 'passive' && (
                                      <span className="text-[10px]">Passive</span>
                                    )}
                                  </button>
                                );
                              })}
                            </div>
                          )}
                        </>
                      )}
                      
                      {/* Show only info button for non-actionable units */}
                      {(currentPlayer !== 1 || selectedUnit.player !== 1 || activatedUnits.has(selectedUnit.id)) && (
                        <button
                          onClick={() => setShowUnitInfo(true)}
                          className="px-4 py-2 bg-blue-700 text-white rounded-lg border border-blue-500 active:bg-blue-600"
                        >
                          ‚ÑπÔ∏è Info
                        </button>
                      )}
                    </div>
                  )}
                </div>
                
                <div className="grid grid-cols-2 gap-1 p-1 bg-gray-900 text-xs flex-shrink-0">
                  <div className="bg-blue-900 p-1 rounded">
                    <div className="flex justify-between items-center mb-1">
                      <span className="text-blue-300 font-bold">P1</span>
                      <span className="text-white">{units.filter(u => u.player === 1 && u.health > 0).length} units</span>
                    </div>
                    <div className="flex items-center gap-1">
                      <div className="flex-1 bg-gray-700 rounded h-2 overflow-hidden">
                        <div 
                          className="bg-blue-400 h-full transition-all"
                          style={{ width: `${(capitalShips.player1?.currentHealth / capitalShips.player1?.health * 100) || 0}%` }}
                        ></div>
                      </div>
                      <span className="text-white text-[10px]">{capitalShips.player1?.currentHealth || 0}</span>
                    </div>
                  </div>
                  <div className="bg-red-900 p-1 rounded">
                    <div className="flex justify-between items-center mb-1">
                      <span className="text-red-300 font-bold">P2</span>
                      <span className="text-white">{units.filter(u => u.player === 2 && u.health > 0).length} units</span>
                    </div>
                    <div className="flex items-center gap-1">
                      <div className="flex-1 bg-gray-700 rounded h-2 overflow-hidden">
                        <div 
                          className="bg-red-400 h-full transition-all"
                          style={{ width: `${(capitalShips.player2?.currentHealth / capitalShips.player2?.health * 100) || 0}%` }}
                        ></div>
                      </div>
                      <span className="text-white text-[10px]">{capitalShips.player2?.currentHealth || 0}</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<StarHexesGame />, document.getElementById('root'));
    </script>
    
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js');
        }
    </script>
</body>
</html>